"""
MiniCRM 表单验证器

负责表单数据的验证逻辑，支持多种验证规则和自定义验证器。
提供统一的验证接口和错误处理机制。
"""

import logging
import re
from collections.abc import Callable
from typing import Any

from PySide6.QtWidgets import QLabel

# 导入transfunctions验证函数
try:
    from transfunctions.validation import (
        validate_customer_data,
        validate_email,
        validate_phone,
    )

    _TRANSFUNCTIONS_AVAILABLE = True
except ImportError:
    _TRANSFUNCTIONS_AVAILABLE = False


class ValidationRule:
    """验证规则类"""

    def __init__(
        self,
        rule_type: str,
        message: str,
        value: Any = None,
        pattern: str = "",
        custom_validator: Callable | None = None,
    ):
        """
        初始化验证规则

        Args:
            rule_type: 规则类型 (required, min_length, max_length, pattern, email, phone, custom)
            message: 错误消息
            value: 规则值（如最小长度、最大长度等）
            pattern: 正则表达式模式
            custom_validator: 自定义验证函数
        """
        self.rule_type = rule_type
        self.message = message
        self.value = value
        self.pattern = pattern
        self.custom_validator = custom_validator


class FormValidator:
    """
    表单验证器类

    提供完整的表单验证功能，包括：
    - 字段级验证
    - 表单级验证
    - 错误消息管理
    - 实时验证支持
    """

    def __init__(self):
        """初始化表单验证器"""
        self._logger = logging.getLogger(f"{__name__}.FormValidator")
        self._validation_rules: dict[str, list[ValidationRule]] = {}
        self._validation_errors: dict[str, str] = {}
        self._error_labels: dict[str, QLabel] = {}

    def add_validation_rule(self, field_key: str, rule: ValidationRule) -> None:
        """
        添加验证规则

        Args:
            field_key: 字段键名
            rule: 验证规则
        """
        if field_key not in self._validation_rules:
            self._validation_rules[field_key] = []

        self._validation_rules[field_key].append(rule)
        self._logger.debug(f"为字段 {field_key} 添加验证规则: {rule.rule_type}")

    def set_error_label(self, field_key: str, error_label: QLabel) -> None:
        """
        设置字段的错误标签

        Args:
            field_key: 字段键名
            error_label: 错误标签组件
        """
        self._error_labels[field_key] = error_label

    def validate_field(self, field_key: str, value: Any) -> bool:
        """
        验证单个字段

        Args:
            field_key: 字段键名
            value: 字段值

        Returns:
            bool: 验证是否通过
        """
        try:
            # 清除之前的错误
            if field_key in self._validation_errors:
                del self._validation_errors[field_key]

            # 获取字段的验证规则
            rules = self._validation_rules.get(field_key, [])

            for rule in rules:
                if not self._validate_single_rule(value, rule):
                    self._validation_errors[field_key] = rule.message
                    self._update_error_display(field_key, rule.message)
                    return False

            # 验证通过，清除错误显示
            self._update_error_display(field_key, "")
            return True

        except Exception as e:
            self._logger.error(f"验证字段 {field_key} 失败: {e}")
            return False

    def validate_form(self, form_data: dict[str, Any]) -> bool:
        """
        验证整个表单 - 使用transfunctions标准验证函数

        Args:
            form_data: 表单数据

        Returns:
            bool: 验证是否通过
        """
        try:
            self._validation_errors.clear()
            is_valid = True

            # 首先尝试使用transfunctions进行整体验证
            if _TRANSFUNCTIONS_AVAILABLE and self._is_customer_form(form_data):
                try:
                    result = validate_customer_data(form_data)
                    if hasattr(result, "is_valid") and not result.is_valid:
                        # 处理transfunctions验证错误
                        if hasattr(result, "errors"):
                            for field, error in result.errors.items():
                                self._validation_errors[field] = error
                                self._update_error_display(field, error)
                        is_valid = False
                except Exception as e:
                    self._logger.warning(f"transfunctions验证失败，使用本地验证: {e}")

            # 验证所有字段（本地验证规则）
            for field_key in self._validation_rules:
                field_value = form_data.get(field_key)
                if not self.validate_field(field_key, field_value):
                    is_valid = False

            self._logger.debug(f"表单验证结果: {'通过' if is_valid else '失败'}")
            return is_valid

        except Exception as e:
            self._logger.error(f"表单验证失败: {e}")
            return False

    def _is_customer_form(self, form_data: dict[str, Any]) -> bool:
        """
        判断是否为客户表单

        Args:
            form_data: 表单数据

        Returns:
            bool: 是否为客户表单
        """
        # 检查是否包含客户表单的关键字段
        customer_fields = ["name", "phone", "company", "email"]
        return any(field in form_data for field in customer_fields)

    def _validate_single_rule(self, value: Any, rule: ValidationRule) -> bool:
        """
        验证单个规则

        Args:
            value: 字段值
            rule: 验证规则

        Returns:
            bool: 验证是否通过
        """
        try:
            if rule.rule_type == "required":
                return self._validate_required(value)
            elif rule.rule_type == "min_length":
                return self._validate_min_length(value, rule.value)
            elif rule.rule_type == "max_length":
                return self._validate_max_length(value, rule.value)
            elif rule.rule_type == "pattern":
                return self._validate_pattern(value, rule.pattern)
            elif rule.rule_type == "email":
                return self._validate_email(value)
            elif rule.rule_type == "phone":
                return self._validate_phone(value)
            elif rule.rule_type == "number":
                return self._validate_number(value, rule.value)
            elif rule.rule_type == "custom":
                return self._validate_custom(value, rule.custom_validator)
            else:
                self._logger.warning(f"未知验证规则类型: {rule.rule_type}")
                return True

        except Exception as e:
            self._logger.error(f"验证规则执行失败: {e}")
            return False

    def _validate_required(self, value: Any) -> bool:
        """验证必填项"""
        if value is None:
            return False

        if isinstance(value, str):
            return bool(value.strip())

        return bool(value)

    def _validate_min_length(self, value: Any, min_length: int) -> bool:
        """验证最小长度"""
        if value is None:
            return True  # 空值由required规则处理

        return len(str(value)) >= min_length

    def _validate_max_length(self, value: Any, max_length: int) -> bool:
        """验证最大长度"""
        if value is None:
            return True

        return len(str(value)) <= max_length

    def _validate_pattern(self, value: Any, pattern: str) -> bool:
        """验证正则表达式模式"""
        if value is None or value == "":
            return True

        return bool(re.match(pattern, str(value)))

    def _validate_email(self, value: Any) -> bool:
        """验证邮箱格式 - 使用transfunctions标准验证函数"""
        if value is None or value == "":
            return True

        if _TRANSFUNCTIONS_AVAILABLE:
            try:
                result = validate_email(str(value))
                return result.is_valid if hasattr(result, "is_valid") else bool(result)
            except Exception:
                # 回退到本地实现
                pass

        # 本地实现作为回退
        email_pattern = r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
        return bool(re.match(email_pattern, str(value)))

    def _validate_phone(self, value: Any) -> bool:
        """验证手机号格式 - 使用transfunctions标准验证函数"""
        if value is None or value == "":
            return True

        if _TRANSFUNCTIONS_AVAILABLE:
            try:
                result = validate_phone(str(value))
                return result.is_valid if hasattr(result, "is_valid") else bool(result)
            except Exception:
                # 回退到本地实现
                pass

        # 本地实现作为回退
        phone_pattern = r"^1[3-9]\d{9}$"
        return bool(re.match(phone_pattern, str(value)))

    def _validate_number(self, value: Any, constraints: dict[str, Any]) -> bool:
        """验证数字范围"""
        if value is None:
            return True

        try:
            num_value = float(value)

            min_val = constraints.get("min")
            max_val = constraints.get("max")

            if min_val is not None and num_value < min_val:
                return False

            if max_val is not None and num_value > max_val:
                return False

            return True

        except (ValueError, TypeError):
            return False

    def _validate_custom(self, value: Any, validator: Callable) -> bool:
        """执行自定义验证"""
        if validator is None:
            return True

        try:
            return validator(value)
        except Exception as e:
            self._logger.error(f"自定义验证器执行失败: {e}")
            return False

    def _update_error_display(self, field_key: str, error_message: str) -> None:
        """
        更新错误显示

        Args:
            field_key: 字段键名
            error_message: 错误消息
        """
        try:
            error_label = self._error_labels.get(field_key)
            if error_label:
                if error_message:
                    error_label.setText(error_message)
                    error_label.show()
                else:
                    error_label.hide()

        except Exception as e:
            self._logger.error(f"更新错误显示失败: {e}")

    def get_validation_errors(self) -> dict[str, str]:
        """
        获取验证错误

        Returns:
            Dict[str, str]: 字段错误映射
        """
        return self._validation_errors.copy()

    def clear_errors(self) -> None:
        """清除所有错误"""
        self._validation_errors.clear()

        for error_label in self._error_labels.values():
            error_label.hide()

    def has_errors(self) -> bool:
        """
        检查是否有验证错误

        Returns:
            bool: 是否有错误
        """
        return bool(self._validation_errors)

    @staticmethod
    def create_required_rule(message: str = "此字段为必填项") -> ValidationRule:
        """创建必填验证规则"""
        return ValidationRule("required", message)

    @staticmethod
    def create_min_length_rule(min_length: int, message: str = "") -> ValidationRule:
        """创建最小长度验证规则"""
        if not message:
            message = f"最少需要 {min_length} 个字符"
        return ValidationRule("min_length", message, min_length)

    @staticmethod
    def create_max_length_rule(max_length: int, message: str = "") -> ValidationRule:
        """创建最大长度验证规则"""
        if not message:
            message = f"最多允许 {max_length} 个字符"
        return ValidationRule("max_length", message, max_length)

    @staticmethod
    def create_email_rule(message: str = "请输入有效的邮箱地址") -> ValidationRule:
        """创建邮箱验证规则"""
        return ValidationRule("email", message)

    @staticmethod
    def create_phone_rule(message: str = "请输入有效的手机号码") -> ValidationRule:
        """创建手机号验证规则"""
        return ValidationRule("phone", message)

    @staticmethod
    def create_pattern_rule(pattern: str, message: str) -> ValidationRule:
        """创建正则表达式验证规则"""
        return ValidationRule("pattern", message, pattern=pattern)

    @staticmethod
    def create_custom_rule(validator: Callable, message: str) -> ValidationRule:
        """创建自定义验证规则"""
        return ValidationRule("custom", message, custom_validator=validator)

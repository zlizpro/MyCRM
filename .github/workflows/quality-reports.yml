# MiniCRM å®šæœŸè´¨é‡æŠ¥å‘Šå·¥ä½œæµ
# å®šæœŸç”Ÿæˆå’Œå‘å¸ƒä»£ç è´¨é‡æŠ¥å‘Š

name: å®šæœŸè´¨é‡æŠ¥å‘Š

on:
  schedule:
    # æ¯å¤©æ—©ä¸Š8ç‚¹ç”Ÿæˆæ¯æ—¥æŠ¥å‘Š
    - cron: "0 8 * * *"
    # æ¯å‘¨ä¸€æ—©ä¸Š9ç‚¹ç”Ÿæˆæ¯å‘¨æŠ¥å‘Š
    - cron: "0 9 * * 1"
    # æ¯æœˆ1å·æ—©ä¸Š10ç‚¹ç”Ÿæˆæ¯æœˆæŠ¥å‘Š
    - cron: "0 10 1 * *"

  # å…è®¸æ‰‹åŠ¨è§¦å‘
  workflow_dispatch:
    inputs:
      report_type:
        description: "æŠ¥å‘Šç±»å‹"
        required: true
        default: "daily"
        type: choice
        options:
          - daily
          - weekly
          - monthly
          - all

jobs:
  generate-reports:
    name: ç”Ÿæˆè´¨é‡æŠ¥å‘Š
    runs-on: ubuntu-latest

    steps:
      - name: æ£€å‡ºä»£ç 
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # è·å–å®Œæ•´å†å²ï¼Œç”¨äºè¶‹åŠ¿åˆ†æ

      - name: è®¾ç½®Pythonç¯å¢ƒ
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: å®‰è£…uv
        uses: astral-sh/setup-uv@v3

      - name: å®‰è£…ä¾èµ–
        run: |
          uv venv
          uv pip install -e .
          uv add --dev ruff mypy pytest pytest-cov coverage

      - name: æ”¶é›†è´¨é‡æŒ‡æ ‡
        run: |
          python scripts/quality_monitor.py

      - name: ç¡®å®šæŠ¥å‘Šç±»å‹
        id: report-type
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "type=${{ github.event.inputs.report_type }}" >> $GITHUB_OUTPUT
          elif [ "$(date +%u)" = "1" ] && [ "$(date +%H)" = "09" ]; then
            echo "type=weekly" >> $GITHUB_OUTPUT
          elif [ "$(date +%d)" = "01" ] && [ "$(date +%H)" = "10" ]; then
            echo "type=monthly" >> $GITHUB_OUTPUT
          else
            echo "type=daily" >> $GITHUB_OUTPUT
          fi

      - name: ç”Ÿæˆè´¨é‡æŠ¥å‘Š
        run: |
          python scripts/quality_reporter.py --type ${{ steps.report-type.outputs.type }}

      - name: ä¸Šä¼ æŠ¥å‘Šæ–‡ä»¶
        uses: actions/upload-artifact@v4
        with:
          name: quality-reports-${{ steps.report-type.outputs.type }}-${{ github.run_number }}
          path: |
            reports/
            quality-trend-report.md
            quality_metrics.json

      - name: åˆ›å»ºIssueï¼ˆå¦‚æœè´¨é‡ä¸‹é™ï¼‰
        if: steps.report-type.outputs.type == 'daily'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // è¯»å–è´¨é‡æŒ‡æ ‡
            let shouldCreateIssue = false;
            let issueBody = '## ğŸš¨ ä»£ç è´¨é‡é¢„è­¦\n\n';

            try {
              const metricsData = JSON.parse(fs.readFileSync('quality_metrics.json', 'utf8'));
              const history = metricsData.history || [];

              if (history.length >= 2) {
                const current = history[history.length - 1];
                const previous = history[history.length - 2];

                // æ£€æŸ¥è´¨é‡ä¸‹é™
                const currentScore = calculateQualityScore(current);
                const previousScore = calculateQualityScore(previous);

                if (currentScore < previousScore - 5) {
                  shouldCreateIssue = true;
                  issueBody += `è´¨é‡è¯„åˆ†ä¸‹é™: ${previousScore.toFixed(1)} â†’ ${currentScore.toFixed(1)}\n\n`;
                }

                // æ£€æŸ¥é—®é¢˜å¢åŠ 
                if (current.ruff_issues > previous.ruff_issues + 10) {
                  shouldCreateIssue = true;
                  issueBody += `Ruffé—®é¢˜å¢åŠ : ${previous.ruff_issues} â†’ ${current.ruff_issues}\n`;
                }

                if (current.mypy_errors > previous.mypy_errors + 5) {
                  shouldCreateIssue = true;
                  issueBody += `MyPyé”™è¯¯å¢åŠ : ${previous.mypy_errors} â†’ ${current.mypy_errors}\n`;
                }

                if (current.coverage_percentage < previous.coverage_percentage - 2) {
                  shouldCreateIssue = true;
                  issueBody += `ä»£ç è¦†ç›–ç‡ä¸‹é™: ${previous.coverage_percentage.toFixed(1)}% â†’ ${current.coverage_percentage.toFixed(1)}%\n`;
                }
              }
            } catch (error) {
              console.log('è¯»å–è´¨é‡æŒ‡æ ‡å¤±è´¥:', error);
            }

            if (shouldCreateIssue) {
              issueBody += '\nè¯·æŸ¥çœ‹æœ€æ–°çš„è´¨é‡æŠ¥å‘Šå¹¶é‡‡å–æ”¹è¿›æªæ–½ã€‚\n\n';
              issueBody += `æŠ¥å‘Šé“¾æ¥: https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;

              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `ä»£ç è´¨é‡é¢„è­¦ - ${new Date().toISOString().split('T')[0]}`,
                body: issueBody,
                labels: ['quality', 'alert']
              });
            }

            function calculateQualityScore(metrics) {
              let score = 100;
              score -= Math.min(metrics.ruff_issues * 0.5, 20);
              score -= Math.min(metrics.mypy_errors * 1.0, 25);
              score -= Math.min(metrics.file_size_violations * 2.0, 15);
              score -= Math.min(metrics.transfunctions_violations * 1.5, 10);

              const coverage = metrics.coverage_percentage || 0;
              if (coverage >= 90) score += 10;
              else if (coverage >= 80) score += 5;
              else if (coverage < 60) score -= 10;

              return Math.max(0, Math.min(100, score));
            }

  publish-reports:
    name: å‘å¸ƒè´¨é‡æŠ¥å‘Š
    needs: generate-reports
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
      - name: æ£€å‡ºä»£ç 
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ä¸‹è½½æŠ¥å‘Šæ–‡ä»¶
        uses: actions/download-artifact@v4
        with:
          pattern: quality-reports-*
          merge-multiple: true

      - name: è®¾ç½®Gité…ç½®
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: æäº¤æŠ¥å‘Šåˆ°ä»“åº“
        run: |
          # åˆ›å»ºreportsåˆ†æ”¯ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
          git checkout -B reports

          # å¤åˆ¶æŠ¥å‘Šæ–‡ä»¶
          mkdir -p docs/quality-reports
          cp -r reports/* docs/quality-reports/ 2>/dev/null || true
          cp quality-trend-report.md docs/quality-reports/ 2>/dev/null || true

          # æ›´æ–°README
          echo "# MiniCRM è´¨é‡æŠ¥å‘Š" > docs/quality-reports/README.md
          echo "" >> docs/quality-reports/README.md
          echo "## æœ€æ–°æŠ¥å‘Š" >> docs/quality-reports/README.md
          echo "" >> docs/quality-reports/README.md

          # åˆ—å‡ºæ‰€æœ‰æŠ¥å‘Šæ–‡ä»¶
          find docs/quality-reports -name "*.md" -not -name "README.md" | sort -r | head -10 | while read file; do
            filename=$(basename "$file")
            echo "- [$filename]($filename)" >> docs/quality-reports/README.md
          done

          # æäº¤æ›´æ”¹
          git add docs/quality-reports/
          if git diff --staged --quiet; then
            echo "æ²¡æœ‰æ–°çš„æŠ¥å‘Šéœ€è¦æäº¤"
          else
            git commit -m "æ›´æ–°è´¨é‡æŠ¥å‘Š - $(date '+%Y-%m-%d %H:%M:%S')"
            git push origin reports --force
          fi

  notify-team:
    name: é€šçŸ¥å›¢é˜Ÿ
    needs: [generate-reports, publish-reports]
    runs-on: ubuntu-latest
    if: always() && (needs.generate-reports.result == 'success' || needs.generate-reports.result == 'failure')

    steps:
      - name: å‘é€Slacké€šçŸ¥
        if: env.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        uses: actions/github-script@v7
        with:
          script: |
            const webhook = process.env.SLACK_WEBHOOK_URL;
            if (!webhook) return;

            const success = '${{ needs.generate-reports.result }}' === 'success';
            const reportType = '${{ steps.report-type.outputs.type }}' || 'daily';

            const payload = {
              channel: '#code-quality',
              username: 'MiniCRM Quality Bot',
              icon_emoji: success ? ':chart_with_upwards_trend:' : ':warning:',
              text: success
                ? `âœ… ${reportType}è´¨é‡æŠ¥å‘Šå·²ç”Ÿæˆ`
                : `âŒ ${reportType}è´¨é‡æŠ¥å‘Šç”Ÿæˆå¤±è´¥`,
              attachments: [{
                color: success ? 'good' : 'danger',
                fields: [
                  {
                    title: 'æŠ¥å‘Šç±»å‹',
                    value: reportType,
                    short: true
                  },
                  {
                    title: 'æ—¶é—´',
                    value: new Date().toLocaleString('zh-CN'),
                    short: true
                  },
                  {
                    title: 'æŸ¥çœ‹è¯¦æƒ…',
                    value: `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
                    short: false
                  }
                ]
              }]
            };

            await fetch(webhook, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });

      - name: å‘é€é‚®ä»¶é€šçŸ¥
        if: env.SMTP_SERVER != ''
        env:
          SMTP_SERVER: ${{ secrets.SMTP_SERVER }}
          SMTP_USERNAME: ${{ secrets.SMTP_USERNAME }}
          SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
          NOTIFICATION_EMAIL: ${{ secrets.NOTIFICATION_EMAIL }}
        run: |
          # è¿™é‡Œå¯ä»¥æ·»åŠ é‚®ä»¶å‘é€é€»è¾‘
          echo "é‚®ä»¶é€šçŸ¥åŠŸèƒ½éœ€è¦é…ç½®SMTPè®¾ç½®"
